<html>
  <head>
    <link
      rel="stylesheet"
      href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css" />
    <meta charset="utf-8" />
    <link rel="icon" type="image/x-icon" href="/Assets/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
    <style>
      @font-face {
        font-family: "Panton";
        src: url("./Fonts/Panton.otf") format("truetype");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }

      html,
      body {
        height: 100%;
        overflow: hidden;
        margin: 0;
        padding: 0;
      }

      body {
        margin: 0;
        font-family: Panton, sans-serif;
        color: white;
        background-color: black;
        background-position: center;
        background-size: cover;
        background-repeat: no-repeat;
        background-image: var(--theme-bg);
        transition: background-image 0.8s ease;
      }

      .pfp {
        position: fixed;
        top: 50%;
        left: 50%;
        width: 200px;
        height: 200px;
        background-color: white;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        overflow: hidden;
        cursor: pointer;
      }

      /* Common styles for floating circles */
      .chaos,
      .settings,
      .shop,
      .solos {
        position: fixed;
        width: 150px; /* adjust size as needed */
        height: 150px;
        cursor: pointer;
        transition: transform 0.3s ease;
        user-select: none;
      }

      /* Enlarge on hover */
      .chaos:hover,
      .settings:hover,
      .shop:hover,
      .solos:hover {
        transform: scale(1.15);
        z-index: 1000;
      }
    </style>
  </head>

  <body>
    <div class="pfp" onclick="window.location.href='./profile.html';"></div>
    <!-- CIRCLES -->
    <img src="./lobby/CHAOS.png" class="chaos" alt="Chaos" />
    <img src="./lobby/SETTINGS.png" class="settings" alt="Settings" />
    <img src="./lobby/SHOP.png" class="shop" alt="Shop" />
    <img src="./lobby/SOLOS.png" class="solos" alt="Solos" />

    <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jwt-decode@3.1.2/build/jwt-decode.min.js"></script>
    <script>
      // Your existing theme and user logic here (unchanged)
      const themes = {
        t1: "./Menu/bg.png",
        t2: "./Profile/MIDNIGHT_BLUE.png",
        t3: "./Profile/TUNDRA_MANGO.png",
        t4: "./Profile/RADIANT_ROCKET_LOLLY.png",
        t5: "./Profile/CHERRIES__CREAM.png",
        t6: "./Profile/SIREN_PURPLE.png",
      };

      function applyStoredTheme() {
        const key = localStorage.getItem("selectedTheme") || "t1";
        const bgUrl = themes[key] || themes["t1"];
        document.body.style.setProperty("--theme-bg", `url(${bgUrl})`);
      }

      window.addEventListener("DOMContentLoaded", () => {
        applyStoredTheme();
      });

      function isTokenValid(token) {
        try {
          const decoded = jwt_decode(token);
          return decoded.exp * 1000 > Date.now();
        } catch {
          return false;
        }
      }

      function renderLoggedOut() {
        localStorage.removeItem("token");
        window.location.href = "index.html";
      }

      document.querySelector(".logout")?.addEventListener("click", () => {
        renderLoggedOut();
      });

      (function () {
        const token = localStorage.getItem("token");
        if (!token || !isTokenValid(token)) {
          renderLoggedOut();
        }
      })();

      function setTheme(key) {
        const now = Date.now();
        if (now - lastChange < 1000) return;
        lastChange = now;

        document.body.style.background = `url(${themes[key].bg}) center/cover fixed no-repeat`;

        const [start, end] = themes[key].gradient || [];
        if (start && end) {
          document.querySelector(
            ".pb-fill"
          ).style.background = `linear-gradient(90deg, ${start} 0%, ${end} 100%)`;
        }

        document
          .querySelectorAll(".t1, .t2, .t3, .t4, .t5, .t6")
          .forEach((el) => el.classList.remove("active-theme"));
        document.querySelector("." + key)?.classList.add("active-theme");

        localStorage.setItem("selectedTheme", key);
      }

      function getXpForLevel(level) {
        return level * 50;
      }

      async function loadUserData() {
        try {
          const response = await fetch("/.netlify/functions/getUserData", {
            headers: {
              Authorization: "Bearer " + localStorage.getItem("token"),
            },
          });
          if (!response.ok) throw new Error("Failed to fetch user data");
          const data = await response.json();

          document.querySelector(".name").textContent = data.username;
          document.querySelector(".level").textContent = `LEVEL: ${data.level
            .toString()
            .padStart(3, "0")}`;
          document.querySelector(".synthc").textContent =
            data.points.toLocaleString();
          document.querySelector(".battlewn").textContent =
            data.battlesWon.toLocaleString();
          document.querySelector(".battleln").textContent =
            data.battlesLost.toLocaleString();

          const neededXp = getXpForLevel(data.level);
          const progress = Math.min(data.xp / neededXp, 0.99);
          document.querySelector(".pb-fill").style.width = `${progress * 100}%`;

          // level badge
          const badge = document.querySelector(".levelb");
          let src = "./Profile/C.png";
          if (data.level >= 1 && data.level <= 10) src = "./Profile/C.png";
          else if (data.level <= 40) src = "./Profile/E.png";
          else if (data.level <= 90) src = "./Profile/R.png";
          else if (data.level <= 110) src = "./Profile/L.png";
          else if (data.level < 200) src = "./Profile/U.png";
          else if (data.level === 200) src = "./Profile/I.png";
          badge.src = src;

          const pfpDiv = document.querySelector(".pfp");
          pfpDiv.innerHTML = `<img src="${data.avatar}" alt="Avatar" style="width:100%;height:100%;object-fit:cover;" />`;
        } catch (err) {
          console.error("Error loading user data:", err);
        }
      }

      window.addEventListener("load", () => {
        const saved = localStorage.getItem("selectedTheme") || "t1";
        setTheme(saved);
        loadUserData();
        setInterval(loadUserData, 5000);
      });

      // --- Floating Circles Logic ---

      const circleSize = 150; // px
      const moveSpeed = 3; // px per frame approx

      class FloatingCircle {
        constructor(el, startX, startY) {
          this.el = el;
          this.width = circleSize;
          this.height = circleSize;

          this.windowWidth = window.innerWidth;
          this.windowHeight = window.innerHeight;

          // Start near the given start position (around pfp)
          this.x = startX;
          this.y = startY;

          // Random small velocity
          this.vx = (Math.random() - 0.5) * moveSpeed;
          this.vy = (Math.random() - 0.5) * moveSpeed;

          this.updatePosition();
        }

        updatePosition() {
          this.el.style.left = this.x + "px";
          this.el.style.top = this.y + "px";
        }

        step() {
          this.x += this.vx;
          this.y += this.vy;

          // Bounce inside window bounds
          if (this.x <= 0) {
            this.x = 0;
            this.vx = -this.vx;
          }
          if (this.x >= this.windowWidth - this.width) {
            this.x = this.windowWidth - this.width;
            this.vx = -this.vx;
          }

          if (this.y <= 0) {
            this.y = 0;
            this.vy = -this.vy;
          }
          if (this.y >= this.windowHeight - this.height) {
            this.y = this.windowHeight - this.height;
            this.vy = -this.vy;
          }

          this.updatePosition();
        }

        updateWindowSize(width, height) {
          this.windowWidth = width;
          this.windowHeight = height;
        }
      }

      const floatingCircles = [];

      function initFloatingCircles() {
        const selectors = [".chaos", ".settings", ".shop", ".solos"];
        const pfp = document.querySelector(".pfp");
        if (!pfp) return;

        // Get .pfp bounding rect and calculate center position in px
        const pfpRect = pfp.getBoundingClientRect();
        const pfpCenterX = pfpRect.left + pfpRect.width / 2 - circleSize / 2;
        const pfpCenterY = pfpRect.top + pfpRect.height / 2 - circleSize / 2;

        const radius = 10; // 10px radius around pfp center to start

        selectors.forEach((selector, i) => {
          const el = document.querySelector(selector);
          if (el) {
            // Distribute angles evenly around circle with some randomness
            const baseAngle = (i * (2 * Math.PI)) / selectors.length;
            // Add a bit of random offset to angle +- 20 degrees (in radians)
            const angleOffset = (Math.random() - 0.5) * (Math.PI / 9); // ~20deg in radians
            const angle = baseAngle + angleOffset;

            const startX = pfpCenterX + radius * Math.cos(angle);
            const startY = pfpCenterY + radius * Math.sin(angle);

            floatingCircles.push(new FloatingCircle(el, startX, startY));
          }
        });
      }

      function animate() {
        floatingCircles.forEach((circle) => circle.step());
        requestAnimationFrame(animate);
      }

      window.addEventListener("resize", () => {
        floatingCircles.forEach((circle) =>
          circle.updateWindowSize(window.innerWidth, window.innerHeight)
        );
      });

      window.addEventListener("DOMContentLoaded", () => {
        initFloatingCircles();
        animate();

        const solos = document.querySelector(".solos");
        if (solos) {
          solos.style.cursor = "pointer";
          solos.addEventListener("click", () => {
            window.location.href = "matchmaking.html";
          });
        }
      });
    </script>
  </body>
</html>
