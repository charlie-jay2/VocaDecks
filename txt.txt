 <!-- <script>
    function getQueryParam(param) {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get(param);
    }

    function saveToken(token) {
      if (typeof token === "string" && token.startsWith("Bearer ")) {
        token = token.slice(7);
      }
      localStorage.setItem("token", token);
      localStorage.setItem("tokenSavedAt", Date.now());

      if (window.history.replaceState) {
        const newUrl =
          window.location.protocol +
          "//" +
          window.location.host +
          window.location.pathname;
        window.history.replaceState({}, document.title, newUrl);
      }
    }

    function getToken() {
      return localStorage.getItem("token");
    }

    function decodeToken(token) {
      try {
        return jwt_decode(token);
      } catch {
        return null;
      }
    }

    function redirectToIndex() {
      window.location.href = "index.html";
    }

    async function fetchUserCards(token) {
      try {
        const response = await fetch(
          `/.netlify/functions/getUserCards?token=${encodeURIComponent(token)}`
        );
        if (!response.ok) throw new Error("Failed to fetch user cards");
        const data = await response.json();
        console.log("Fetched cards:", data.cards);
        return data.cards || [];
      } catch (error) {
        console.error(error);
        throw error;
      }
    }

    function updateStatsDisplay(stats) {
      if (!stats) return;

      const healthpo = document.querySelector(".healthpo");
      const healthpt = document.querySelector(".healthpt");
      const damagelpo = document.querySelector(".damagelpo");
      const damagelpt = document.querySelector(".damagelpt");

      console.log("Updating stats display:", stats);

      if (healthpo) {
        healthpo.textContent =
          stats.playerOneHealth != null ? stats.playerOneHealth : "0";
      } else {
        console.warn("Element .healthpo not found");
      }

      if (healthpt) {
        healthpt.textContent =
          stats.playerTwoHealth != null ? stats.playerTwoHealth : "0";
      } else {
        console.warn("Element .healthpt not found");
      }

      if (damagelpo) {
        damagelpo.textContent =
          stats.playerOneDamage != null ? stats.playerOneDamage : "0";
      } else {
        console.warn("Element .damagelpo not found");
      }

      if (damagelpt) {
        damagelpt.textContent =
          stats.playerTwoDamage != null ? stats.playerTwoDamage : "0";
      } else {
        console.warn("Element .damagelpt not found");
      }
    }

    function showDiscordUserInfo(user) {
      const container = document.getElementById("discordUserInfo");
      if (!container) return;

      container.style.display = "block";
      container.innerHTML = `
      <div class="user-row">
        <img src="https://cdn.discordapp.com/avatars/${user.id}/${user.avatar}.png?size=64" alt="avatar" />
        <span class="username" title="${user.username}">${user.username}</span>
      </div>
    `;
    }

    function displayCardImage(cardName, containerId = "selectedCardContainer") {
      const container = document.getElementById(containerId);
      if (!container) return;

      if (!cardName) {
        container.innerHTML = "";
        if (containerId === "selectedCardContainer") updateStatsDisplay(null);
        return;
      }

      const encodedFileName = encodeURIComponent(cardName);
      const imgSrc = `./Cards/${encodedFileName}`;
      console.log(`ðŸ“¸ Displaying in #${containerId}:`, imgSrc);

      container.innerHTML = `<img src="${imgSrc}" alt="Selected Card" style="
      width: 90%;
      height: auto;
      position: absolute;
      ${
        containerId === "playerTwoCardContainer"
          ? "left: 43%; bottom: 15;"
          : "left: 26.5%; bottom: 15;"
      }
      z-index: 1;
    " />`;
    }

    function formatCardNameWithRarity(name) {
      let cleanName = name;

      if (!cleanName.toLowerCase().endsWith(".png")) {
        cleanName += ".png";
      }

      const rarityMatch = cleanName.match(/^r([1-5])/i);
      if (!rarityMatch) return cleanName.replace(/\.png$/i, "");

      const rarityMap = {
        1: "COMMON",
        2: "EXTRA",
        3: "RARE",
        4: "LEGENDARY",
        5: "UNTOUCHED",
      };

      const baseName = cleanName.replace(/^r[1-5]/i, "").replace(/\.png$/i, "");
      return `${baseName.trim()} (${rarityMap[rarityMatch[1]] || "UNKNOWN"})`;
    }

    function getCardRarity(name) {
      const rarityMatch = name.match(/^r([1-5])/i);
      if (!rarityMatch) return null;
      const rarityMap = {
        1: "COMMON",
        2: "EXTRA",
        3: "RARE",
        4: "LEGENDARY",
        5: "UNTOUCHED",
      };
      return rarityMap[rarityMatch[1]] || null;
    }

    async function init() {
      let token = getToken();

      if (!token) {
        const urlToken = getQueryParam("token");
        if (urlToken) {
          saveToken(urlToken);
          token = urlToken;
        } else {
          console.log("No token found, redirect or handle accordingly");
          return;
        }
      }

      const decoded = decodeToken(token);
      if (!decoded || !decoded.username || !decoded.id || !decoded.avatar) {
        localStorage.removeItem("token");
        localStorage.removeItem("tokenSavedAt");
        console.log("Invalid token, redirect or handle accordingly");
        return;
      }

      showDiscordUserInfo(decoded);

      const playerOneHeading = document.querySelector(".text1");
      if (playerOneHeading) {
        playerOneHeading.textContent = decoded.username.toUpperCase();
      }

      const matchedOpponent =
        localStorage.getItem("matchedOpponent") || "PLAYER TWO";
      const playerTwoHeading = document.getElementById("playerTwoUsername");
      if (playerTwoHeading) {
        playerTwoHeading.textContent = matchedOpponent.toUpperCase();
      }

      const selectedRarity =
        localStorage.getItem("selectedRarity")?.toLowerCase() || null;
      console.log("ðŸŽ¯ Selected rarity filter:", selectedRarity);

      // Restore currentRole from storage for reconnects/reloads
      currentRole = localStorage.getItem("yourRole");
      console.log("Restored currentRole from storage:", currentRole);

      const cards = await fetchUserCards(token);
      const dropdown = document.getElementById("playerOneCards");

      if (dropdown) {
        dropdown.innerHTML = `<option value="">-- Your Cards --</option>`;

        cards.forEach((card) => {
          let val = (card.name || card.id || card).trim();
          if (!val.toLowerCase().endsWith(".png")) {
            val += ".png";
          }

          const lowerVal = val.toLowerCase();
          const cardRarity = getCardRarity(val);

          const isMikudayo =
            lowerVal === "mikudayo.png" || lowerVal === "cherry mikudayo.png";

          if (
            isMikudayo || // Always show Mikudayo
            !selectedRarity || // No rarity filter, show all
            (cardRarity && cardRarity.toLowerCase() === selectedRarity)
          ) {
            const option = document.createElement("option");
            option.value = val;
            option.textContent = isMikudayo
              ? val.replace(/\.png$/i, "")
              : formatCardNameWithRarity(val);
            dropdown.appendChild(option);
          }
        });

        dropdown.addEventListener("change", (e) => {
          displayCardImage(e.target.value, "selectedCardContainer");
          sendCardSelection(e.target.value);

          // NEW: request own card stats on selection
          if (
            socket &&
            socket.readyState === WebSocket.OPEN &&
            e.target.value
          ) {
            const payload = { type: "getCardStats", cardName: e.target.value };
            socket.send(JSON.stringify(payload));
          }
        });
      }

      setupWebSocket(token, decoded.username);
    }

    let socket;
    let currentUsername;
    let currentRole = null;

    function setupWebSocket(token, username) {
      currentUsername = username;

      const wsUrl = "wss://vdbe-0f2p.onrender.com";
      socket = new WebSocket(`${wsUrl}?token=${encodeURIComponent(token)}`);

      socket.addEventListener("open", () => {
        console.log("ðŸ”— WebSocket connected");
      });

      socket.addEventListener("message", (event) => {
        let msg;
        try {
          msg = JSON.parse(event.data);
        } catch {
          console.warn("âš ï¸ Non-JSON WS message:", event.data);
          return;
        }

        if (msg.type === "welcome") {
          console.log(msg.message);
        } else if (msg.type === "status") {
          console.log("Status:", msg.message);
        } else if (msg.type === "opponentSelection") {
          console.log(
            `ðŸŽ´ Opponent (${msg.username}) selected: ${msg.cardName}`
          );

          if (msg.username !== currentUsername) {
            // Show opponent's card image
            displayCardImage(msg.cardName, "playerTwoCardContainer");

            // Request opponent's card stats
            requestCardStats(msg.cardName);
          }
        } else if (msg.type === "matched") {
          console.log(`âœ… Connected to ${msg.opponent}`);
          console.log(`ðŸ§‘â€ðŸ’» You are: ${msg.yourName} (${msg.role})`);

          localStorage.setItem("matchedOpponent", msg.opponent);
          localStorage.setItem("yourName", msg.yourName);
          localStorage.setItem("yourRole", msg.role);

          currentRole = msg.role;
          console.log("Set currentRole to:", currentRole);

          const p2Name = document.getElementById("playerTwoUsername");
          if (p2Name) p2Name.textContent = msg.opponent.toUpperCase();
        } else if (msg.type === "cardStats") {
          console.log("ðŸ“Š Received cardStats message:", msg);

          if (msg.cardName) {
            const selectedCard =
              document.getElementById("playerOneCards").value;
            const playerTwoCardContainer = document.getElementById(
              "playerTwoCardContainer"
            );
            const playerTwoCardHTML = playerTwoCardContainer
              ? playerTwoCardContainer.innerHTML.toLowerCase()
              : "";

            console.log("Checking cardStats for display:", {
              selectedCard,
              playerTwoCardHTML,
              msgCardName: msg.cardName,
              currentRole,
            });

            if (!currentRole) {
              console.warn(
                "âš ï¸ currentRole is not set properly, cannot update stats"
              );
              return;
            }

            // Update Player One stats if this is their selected card and they are Player One
            if (selectedCard === msg.cardName && currentRole === "Player One") {
              updateStatsDisplay({
                playerOneHealth: msg.SP, // SP â†’ Health Player One
                playerOneDamage: msg.VR, // VR â†’ Damage Player One
                playerTwoHealth:
                  parseInt(document.querySelector(".healthpt")?.textContent) ||
                  0,
                playerTwoDamage:
                  parseInt(document.querySelector(".damagelpt")?.textContent) ||
                  0,
              });
            }

            // Update Player Two stats if this card is shown in the playerTwoCardContainer and user is Player Two
            if (
              playerTwoCardHTML.includes(msg.cardName.toLowerCase()) &&
              currentRole === "Player Two"
            ) {
              updateStatsDisplay({
                playerOneHealth:
                  parseInt(document.querySelector(".healthpo")?.textContent) ||
                  0,
                playerOneDamage:
                  parseInt(document.querySelector(".damagelpo")?.textContent) ||
                  0,
                playerTwoHealth: msg.SP, // SP â†’ Health Player Two
                playerTwoDamage: msg.VR, // VR â†’ Damage Player Two
              });
            }
          }
        }
      });

      socket.addEventListener("close", () => {
        console.log("âŒ WebSocket disconnected");
      });

      socket.addEventListener("error", (error) => {
        console.error("ðŸš¨ WebSocket error:", error);
      });
    }

    function sendCardSelection(cardName) {
      if (socket && socket.readyState === WebSocket.OPEN && cardName) {
        const payload = {
          type: "selection",
          cardName: cardName,
        };
        console.log("ðŸ“¤ Sending card selection:", payload);
        socket.send(JSON.stringify(payload));
      }
    }

    function requestCardStats(cardName) {
      if (socket && socket.readyState === WebSocket.OPEN && cardName) {
        const payload = {
          type: "getCardStats",
          cardName: cardName,
        };
        console.log("ðŸ“¤ Requesting card stats:", payload);
        socket.send(JSON.stringify(payload));
      }
    }

    init();
  </script> -->


  -----------------------

      <script>
      const audio = new Audio("audio/Battle.wav");
      audio.loop = true;
      audio.volume = 0.7;

      const iconMuted = document.getElementById("icon-muted");
      const iconUnmuted = document.getElementById("icon-unmuted");
      const toggleBtn = document.getElementById("audio-toggle");

      let isMuted = false;

      function updateIcons() {
        if (isMuted) {
          iconMuted.style.display = "block";
          iconUnmuted.style.display = "none";
        } else {
          iconMuted.style.display = "none";
          iconUnmuted.style.display = "block";
        }
      }

      toggleBtn.addEventListener("click", () => {
        isMuted = !isMuted;
        audio.muted = isMuted;
        updateIcons();
      });

      // Try autoplay after 1 second
      window.addEventListener("DOMContentLoaded", () => {
        setTimeout(() => {
          audio.play().catch(() => {
            // Autoplay failed, wait for user interaction
            const resume = () => {
              audio.play().catch(console.warn);
              document.removeEventListener("click", resume);
            };
            document.addEventListener("click", resume, { once: true });
          });
        }, 1000);
      });

      updateIcons(); // initial icon state
    </script>

    <script>
      const cursor = document.getElementById("fluid-glass-cursor");

      let mouseX = window.innerWidth / 2;
      let mouseY = window.innerHeight / 2;
      let currentX = mouseX;
      let currentY = mouseY;
      const speed = 0.15;

      window.addEventListener("mousemove", (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      function animate() {
        currentX += (mouseX - currentX) * speed;
        currentY += (mouseY - currentY) * speed;

        cursor.style.left = `${currentX}px`;
        cursor.style.top = `${currentY}px`;

        requestAnimationFrame(animate);
      }
      animate();

      // Checks if element is clickable or matches .v or .h specifically
      function isClickableOrSpecial(el) {
        if (!el) return false;
        const style = window.getComputedStyle(el);
        return (
          el.onclick ||
          el.tagName === "BUTTON" ||
          el.tagName === "A" ||
          el.tagName === "SUMMARY" ||
          el.getAttribute("role") === "button" ||
          el.tabIndex >= 0 ||
          style.cursor === "pointer" ||
          el.classList.contains("v") ||
          el.classList.contains("h")
        );
      }

      document.addEventListener("mouseover", (e) => {
        if (isClickableOrSpecial(e.target)) {
          cursor.style.width = "50px";
          cursor.style.height = "50px";
          cursor.style.backgroundColor = "rgba(255, 255, 255, 0.15)";
          cursor.style.backdropFilter = "none";
          cursor.style.webkitBackdropFilter = "none";
        }
      });

      document.addEventListener("mouseout", (e) => {
        if (isClickableOrSpecial(e.target)) {
          cursor.style.width = "30px";
          cursor.style.height = "30px";
          cursor.style.backgroundColor = "rgba(255, 255, 255, 0.507)";
          cursor.style.backdropFilter = "blur(5px)";
          cursor.style.webkitBackdropFilter = "blur(5px)";
        }
      });
    </script>

    <script>
      const themes = {
        t1: "./Menu/bg.png",
        t2: "./Profile/MIDNIGHT_BLUE.png",
        t3: "./Profile/TUNDRA_MANGO.png",
        t4: "./Profile/RADIANT_ROCKET_LOLLY.png",
        t5: "./Profile/CHERRIES__CREAM.png",
        t6: "./Profile/SIREN_PURPLE.png",
      };

      function applyStoredTheme() {
        const key = localStorage.getItem("selectedTheme") || "t1";
        const bgUrl = themes[key] || themes["t1"];
        document.body.style.setProperty("--theme-bg", `url(${bgUrl})`);
      }

      window.addEventListener("DOMContentLoaded", () => {
        applyStoredTheme();
        localStorage.setItem("healthpo", "100");
        localStorage.setItem("healthpt", "100");

        // Healthpo logic
        const selectsPo = {
          1: document.querySelector(".selectpo1"),
          2: document.querySelector(".selectpo2"),
          3: document.querySelector(".selectpo3"),
          4: document.querySelector(".selectpo4"),
        };

        function updateSelectVisibilityPo() {
          const healthStr = localStorage.getItem("healthpo");
          const health = healthStr !== null ? Number(healthStr) : null;

          Object.values(selectsPo).forEach((el) => {
            el.classList.remove("visible");
            if (el.classList.contains("selectpo4")) {
              el.classList.remove("solid");
            }
          });

          if (health === null) return;

          if (health >= 80) {
            selectsPo[1].classList.add("visible");
          } else if (health >= 50) {
            selectsPo[2].classList.add("visible");
          } else if (health >= 20) {
            selectsPo[3].classList.add("visible");
          } else if (health === 0) {
            selectsPo[4].classList.add("visible", "solid");
          } else {
            selectsPo[4].classList.add("visible");
          }
        }

        updateSelectVisibilityPo();
        setInterval(updateSelectVisibilityPo, 500);

        // Healthpt logic
        const selectsPt = {
          1: document.querySelector(".select1"),
          2: document.querySelector(".select2"),
          3: document.querySelector(".select3"),
          4: document.querySelector(".select4"),
        };

        function updateSelectVisibilityPt() {
          const healthStr = localStorage.getItem("healthpt");
          const health = healthStr !== null ? Number(healthStr) : null;

          Object.values(selectsPt).forEach((el) => {
            el.classList.remove("visible");
            if (el.classList.contains("select4")) {
              el.classList.remove("solid");
            }
          });

          if (health === null) return;

          if (health >= 80) {
            selectsPt[1].classList.add("visible");
          } else if (health >= 50) {
            selectsPt[2].classList.add("visible");
          } else if (health >= 20) {
            selectsPt[3].classList.add("visible");
          } else if (health === 0) {
            selectsPt[4].classList.add("visible", "solid");
          } else {
            selectsPt[4].classList.add("visible");
          }
        }

        updateSelectVisibilityPt();
        setInterval(updateSelectVisibilityPt, 500);

        // Tooltip logic
        const vBar = document.querySelector(".v");
        const hBar = document.querySelector(".h");
        const vrTooltip = document.getElementById("vrtt");
        const vrValue = document.querySelector(".vrttt");
        const healthTooltip = document.getElementById("healthtt");
        const healthValue = document.querySelector(".healthttt");

        function setupTooltip(bar, tooltip, valueEl) {
          bar.addEventListener("mousemove", (e) => {
            const rect = bar.getBoundingClientRect();
            let y = e.clientY - rect.top;
            y = Math.min(Math.max(y, 0), rect.height);
            const rawPercent = (1 - y / rect.height) * 100;

            // Clamp value between 5 and 99, then round
            const clampedPercent = Math.min(
              Math.max(Math.round(rawPercent), 1),
              100
            );

            valueEl.textContent = clampedPercent;
            tooltip.style.display = "flex";
            tooltip.style.opacity = "1";
            tooltip.style.pointerEvents = "none";

            const offsetX = -30;
            const offsetY = 10;
            tooltip.style.top = `${e.clientY + offsetY}px`;
            tooltip.style.left = `${
              e.clientX - offsetX - tooltip.offsetWidth
            }px`;
          });

          bar.addEventListener("mouseleave", () => {
            tooltip.style.display = "none";
            tooltip.style.opacity = "0";
          });
        }

        setupTooltip(vBar, vrTooltip, vrValue);
        setupTooltip(hBar, healthTooltip, healthValue);
      });
    </script>